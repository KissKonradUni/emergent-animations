\pagebreak

\section{Algorithms}
\label{sec:algorithms}

\subsection{Functional animation}
\label{subsec:functional-animation}

Functional animation treats an animation as a pure function from time to state. In this example we will create a simple animation of an object following a circular path.

\Example{https://kisskonraduni.github.io/emergent-animations/examples/functional-animations?tab=0}{Example can be found here}

I have defined two simple functions that set the value of an object's position over time using these parameters:
\begin{align*}
    r &: \text{radius} & \alpha &: \text{starting angle} \\
    t &: \text{time} & \omega &: \text{angular speed (rad/s)}
\end{align*}

Assuming our object is rotated around the origin, or if necessary offset using the object's pivot point, or a parent object, the position \(\vv{p}\) of the object at time \(t\) can be calculated as follows:
\begin{align*}
    x(t) &= r\cos(\alpha + \omega t) \\
    y(t) &= r\sin(\alpha + \omega t) \\
    \vv{p}(t) &= [x(t), y(t)]
\end{align*}

Positive \(\omega\) will rotate the object counter-clockwise, while negative \(\omega\) will rotate it clockwise. Using these simple equations, we can create a simple animation for a clearly defined path.

Here is the code that implements this exact animation:
\inputminted{typescript}{code/functional-animation.tex}

While animating an object along a circular path using these equations is straightforward, this approach has significant limitations. It is difficult to construct complex or precise paths, the resulting animation lacks adaptability, and synchronizing its timing with other animations is challenging. Nevertheless, this method can be extended to address some of these issues.

\begin{Note}
    As a sidenote, this animation can also be achieved using the parenting system. Instead of setting the object's position directly, its initial position is set to the edge of the circle, and the parent object is rotated. This produces a similar animation, although the entire circle will rotate as well.
\end{Note}

\begin{table}[H]
    \centering
    \begin{tblr}{
        colspec={|c|c|c|c|c|},
        vlines = {abovepos = 1, belowpos = 1},
        hlines,
        hline{2} = {1}{-}{solid},
        hline{2} = {2}{-}{solid},
        row{1} = {font=\bfseries}
    }
        Deviation & Repetition & Control & Feel & Performance \\
        \(0.0\) & \(1.0\) & Total & \(0.15\) & \(O(1)\) \\
    \end{tblr}
    \caption{Measurements for the functional animation algorithm.}
    \label{tab:functional-animation-measurements}
\end{table}

\vspace{80pt}

\subsection{Interpolation based animation}
\label{subsec:interpolation-animation}

A more advanced and widely used approach in animation is keyframe interpolation\footnote{
    Interpolation is a method of constructing new data points within the range of a discrete set of known data points. In animation, it is used to create smooth transitions between keyframes by calculating intermediate frames based on the defined keyframes.
}. In this method, the start and end values of the animation, as well as its duration, are defined. A simple equation then calculates the object's position at any given time. These animations can be started, stopped, and reversed at any time, and will always produce the same result for identical input parameters. This predictability makes them easy to control.

\pagebreak

The basic equation for \textbf{linear} interpolation is:
\begin{align*}
    a&: \text{start value} & t_0&: \text{start time} \\
    b&: \text{end value}   & t_1&: \text{end time}   \\
    r(t)&: \text{result}      & t  &: \text{current time}
\end{align*}
\begin{align*}
    \Delta t &= t_1 - t_0 \\
    r(t) &= a + (b - a) \cdot \frac{t - t_0}{\Delta t}
\end{align*}

This equation produces a smooth transition from \(a\) to \(b\) over the interval \([t_0, t_1]\). It should be evaluated once per frame.

\begin{Note}
    In my implementation, I have created a simple \textbf{Interpolator} class that handles the interpolation for you. It takes care of the timing and the calculation of the result, so you can just use it to get the current value of the animation. Also, you just have to start it in the \textbf{sequence} generator function, and it will automatically update the value every frame.
\end{Note}

A common question arises: how can we make the animation appear less mechanical? This can be achieved by using \textbf{easing functions}, which modify the timing of linear interpolations to create more natural motion. Easing functions can introduce acceleration, deceleration, and other effects that make the animation feel more fluid.

\begin{Note}
    I have implemented a simple \textbf{Easing} class that provides a set of common easing functions, like \textbf{ease-in}, \textbf{ease-out}, and \textbf{ease-in-out}. The basic syntax is really simple, so you can define your own easing functions easily. There are some basic rules to follow when creating valid easing functions: the function should take a value between \(0\) and \(1\) as input, and return \(0\) at \(0\) and \(1\) at \(1\). An excellent resource for common easing functions is \cite{easings}.
\end{Note}

The correct method to integrate easing functions into the interpolation is as follows:
\begin{align*}
    \epsilon(t)&: \text{easing function} \\
    t &: \text{current time} \\
    \\
    r(t) &= a + (b - a) \cdot \epsilon\left(\frac{t - t_0}{\Delta t}\right)
\end{align*}

\Example{https://kisskonraduni.github.io/emergent-animations/examples/functional-animations?tab=1}{Example can be found here}

\pagebreak

Interpolation-based animation is one of the most widely used methods in computer graphics and user interface design. It is straightforward to implement, offers precise control, and produces smooth transitions. This technique forms the foundation of most animation software, game engines, and even simple UI frameworks. Furthermore, it serves as the basis for many advanced animation techniques.

\begin{table}[H]
    \centering
    \begin{tblr}{
        colspec={|c|c|c|c|c|},
        vlines = {abovepos = 1, belowpos = 1},
        hlines,
        hline{2} = {1}{-}{solid},
        hline{2} = {2}{-}{solid},
        row{1} = {font=\bfseries}
    }
        Deviation & Repetition & Control & Feel & Performance \\
        \text{Defined below} & \(1.0\) & High & \(0.8\) & \(O(1)\) \\
    \end{tblr}
    \caption{Measurements for the interpolation based animation algorithm.}
    \label{tab:interpolation-animation-measurements}
\end{table}

The deviation for this algorithm is defined as the integral of the absolute difference between the linear function and the chosen easing function:
\begin{align*}
    l(t) = t &: \text{linear function} \\
    \epsilon(t) &: \text{easing function} \\
    \bar{D} &= \int_{t=0}^{1} \left| l(t) - \epsilon(t) \right| dt
\end{align*}

\vspace{60pt}

\subsubsection{Timelines and sequencing}
\label{subsubsec:timelines-sequencing}

Many practical animations are compositions of multiple steps rather than a single, fixed-duration function. Timelines and sequencing provide a simple abstraction for assembling such compositions.

A \textbf{timeline} is an ordered collection of animations (or sequences) that are played one after another. Timelines may themselves be composed and can be executed in parallel with other timelines so that multiple objects are animated independently. A \textbf{sequence} is a single animation described by a set of keyframes or an interpolation procedure; it represents one contiguous part of a timeline.

\begin{Note}
    In this implementation, each timeline is represented as a generator function, following the same pattern as the \textbf{sequence} generator. To run multiple timelines concurrently, you create separate generator functions for each timeline and pass their generator instances to a parallel runner. For example, you can yield the parallel helper (represented here as {\footnotesize\texttt{Animator.runParallel(...)}}) from the main \textbf{sequence} generator to execute multiple timelines at the same time.
\end{Note}

\pagebreak

\begin{Note}
    When defining sequences within a timeline, the provided \textbf{InterpolationSequence} class uses a per-keyframe \textbf{duration} convention: each keyframe specifies the time interval from the previous keyframe to itself, rather than an absolute timestamp. This approach streamlines both implementation and editing, as you directly control the duration of each segment. However, it differs from traditional absolute-time timelines, where each keyframe has a specific time value. If needed, you can easily convert between these representations: cumulative sums of durations yield absolute times, while differences between absolute times yield per-segment durations. This system was chosen for its simplicity and efficiency, but it remains flexible enough to support absolute-time timelines if required.
\end{Note}

\Example{https://kisskonraduni.github.io/emergent-animations/examples/functional-animations?tab=2}{An example sequence can be found here}
\Example{https://kisskonraduni.github.io/emergent-animations/examples/functional-animations?tab=3}{and a more complex example can be found here}

\vspace{60pt}

\subsection{Frame animations}
\label{subsec:frame-animations}

Frame animations are a common technique in computer graphics, particularly in 2D animation. They're based on the original concepts of filmmaking, where a series of still images are displayed in rapid succession to create the illusion of motion. In computer graphics, this is often implemented as a sequence of images or frames that are displayed one after another. Compression algorithms, sprite sheets, and similar techniques may cause the implementation to differ slightly, but the basic principle remains the same.

\begin{Note}
    In this implementation, I utilize spritesheets to store the frames of the animation, and a function to control which frame is shown at any given time. To use this, you need to define a regular \textbf{CanvasObject} and use the {\footnotesize\texttt{Objects.sprite(...)}} drawing function.
\end{Note}

\Example{https://kisskonraduni.github.io/emergent-animations/examples/frame-animations?tab=0}{An example frame animation can be found here}

\pagebreak

While frame animations are simple in concept, they can be combined with other techniques to create more complex results. For example, you can use frame animations to create a character that moves around the screen, while using interpolation to control the speed and direction of movement. This allows for a wide range of possibilities and can lead to interesting results.

I have created an example\footnote{
    This is not intended as a serious example; I created it while experimenting with the implementation. Surprisingly, it demonstrates how frame animations can be combined with other techniques, such as interpolation and parenting, to create more complex animations. It also shows how the implementation can be used to create animations with minimal effort.
} to show that these techniques are not mutually exclusive, and can be combined to create more complex animations. The example is a simple "pendulum" with three cats, each using its own frame animation.

\Example{https://kisskonraduni.github.io/emergent-animations/examples/frame-animations?tab=1}{Example can be found here}

\begin{table}[H]
    \centering
    \begin{tblr}{
        colspec={|c|c|c|c|c|},
        vlines = {abovepos = 1, belowpos = 1},
        hlines,
        hline{2} = {1}{-}{solid},
        hline{2} = {2}{-}{solid},
        row{1} = {font=\bfseries}
    }
        Deviation & Repetition & Control & Feel & Performance \\
        \(0.0\) & \(1.0\) & Total & \(N/A\) & \(O(1)\) \\
    \end{tblr}
    \caption{Measurements for the frame animation algorithm.}
    \label{tab:frame-animation-measurements}
\end{table}

The reason for omitting the feel measurement is that frame animations are not inherently tied to any specific timing or easing function. They simply display a sequence of images at a fixed rate, which can be adjusted independently of the animation itself. The feel of the animation is determined by the choice of frames and their timing, rather than the algorithm itself.
