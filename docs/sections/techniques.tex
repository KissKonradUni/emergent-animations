\pagebreak

\section{Techniques}
\label{sec:techniques}

\subsection{Functional animation}
\label{subsec:functional-animation}

Functional animation treats an animation as a pure function from time to state. In this example we will create a simple animation of an object following a circular path.

\Example{https://kisskonraduni.github.io/emergent-animations/examples/functional-animations?tab=0}{Example can be found here}

I have defined two simple functions that set the value of an object's position over time using these parameters:
\begin{align*}
    r &: \text{radius} & \alpha &: \text{starting angle} \\
    t &: \text{time} & \omega &: \text{angular speed (rad/s)}
\end{align*}

Assuming our object is rotated around the origin, or if necessary offset using the object's pivot point, or a parent object, the position \(\vv{p}\) of the object at time \(t\) can be calculated as follows:
\begin{align*}
    x(t) &= r\cos(\alpha + \omega t) \\
    y(t) &= r\sin(\alpha + \omega t) \\
    \vv{p}(t) &= [x(t), y(t)]
\end{align*}

Positive \(\omega\) will rotate the object counter-clockwise, while negative \(\omega\) will rotate it clockwise. Using these simple equations, we can create a simple animation for a clearly defined path.

Here is the code that implements this exact animation:
\inputminted{typescript}{code/functional-animation.tex}

While animating an object along a circular path using these equations is straightforward, this approach has significant limitations. It is difficult to construct complex or precise paths, the resulting animation lacks adaptability, and synchronizing its timing with other animations is challenging. Nevertheless, this method can be extended to address some of these issues.

\begin{Note}
    As a sidenote, this animation can also be achieved using the parenting system. Instead of setting the object's position directly, its initial position is set to the edge of the circle, and the parent object is rotated. This produces a similar animation, although the entire circle will rotate as well.
\end{Note}

\begin{table}[H]
    \centering
    \begin{tblr}{
        colspec={|c|c|c|c|c|},
        vlines = {abovepos = 1, belowpos = 1},
        hlines,
        hline{2} = {1}{-}{solid},
        hline{2} = {2}{-}{solid},
        row{1} = {font=\bfseries}
    }
        Deviation & Repetition & Control & Feel & Performance \\
        \(0.0\) & \(1.0\) & Total & \(0.15\) & \(O(1)\) \\
    \end{tblr}
    \caption{Measurements for the functional animation algorithm.}
    \label{tab:functional-animation-measurements}
\end{table}

\vspace{80pt}

\subsection{Interpolation based animation}
\label{subsec:interpolation-animation}

A more advanced and widely used approach in animation is keyframe interpolation\footnote{
    Interpolation is a method of constructing new data points within the range of a discrete set of known data points. In animation, it is used to create smooth transitions between keyframes by calculating intermediate frames based on the defined keyframes.
}. In this method, the start and end values of the animation, as well as its duration, are defined. A simple equation then calculates the object's position at any given time. These animations can be started, stopped, and reversed at any time, and will always produce the same result for identical input parameters. This predictability makes them easy to control.

\pagebreak

The basic equation for \textbf{linear} interpolation is:
\begin{align*}
    a&: \text{start value} & t_0&: \text{start time} \\
    b&: \text{end value}   & t_1&: \text{end time}   \\
    r(t)&: \text{result}      & t  &: \text{current time}
\end{align*}
\begin{align*}
    \Delta t &= t_1 - t_0 \\
    r(t) &= a + (b - a) \cdot \frac{t - t_0}{\Delta t}
\end{align*}

This equation produces a smooth transition from \(a\) to \(b\) over the interval \([t_0, t_1]\). It should be evaluated once per frame.

\begin{Note}
    In my implementation, I have created a simple \textbf{Interpolator} class that handles the interpolation for you. It takes care of the timing and the calculation of the result, so you can just use it to get the current value of the animation. Also, you just have to start it in the \textbf{sequence} generator function, and it will automatically update the value every frame.
\end{Note}

A common question arises: how can we make the animation appear less mechanical? This can be achieved by using \textbf{easing functions}, which modify the timing of linear interpolations to create more natural motion. Easing functions can introduce acceleration, deceleration, and other effects that make the animation feel more fluid.

\begin{Note}
    I have implemented a simple \textbf{Easing} class that provides a set of common easing functions, like \textbf{ease-in}, \textbf{ease-out}, and \textbf{ease-in-out}. The basic syntax is really simple, so you can define your own easing functions easily. There are some basic rules to follow when creating valid easing functions: the function should take a value between \(0\) and \(1\) as input, and return \(0\) at \(0\) and \(1\) at \(1\). An excellent resource for common easing functions is \cite{easings}.
\end{Note}

The correct method to integrate easing functions into the interpolation is as follows:
\begin{align*}
    \epsilon(t)&: \text{easing function} \\
    t &: \text{current time} \\
    \\
    r(t) &= a + (b - a) \cdot \epsilon\left(\frac{t - t_0}{\Delta t}\right)
\end{align*}

\Example{https://kisskonraduni.github.io/emergent-animations/examples/functional-animations?tab=1}{Example can be found here}

\pagebreak

Interpolation-based animation is one of the most widely used methods in computer graphics and user interface design. It is straightforward to implement, offers precise control, and produces smooth transitions. This technique forms the foundation of most animation software, game engines, and even simple UI frameworks. Furthermore, it serves as the basis for many advanced animation techniques.

\begin{table}[H]
    \centering
    \begin{tblr}{
        colspec={|c|c|c|c|c|},
        vlines = {abovepos = 1, belowpos = 1},
        hlines,
        hline{2} = {1}{-}{solid},
        hline{2} = {2}{-}{solid},
        row{1} = {font=\bfseries}
    }
        Deviation & Repetition & Control & Feel & Performance \\
        \text{Defined below} & \(1.0\) & High & \(0.8\) & \(O(1)\) \\
    \end{tblr}
    \caption{Measurements for the interpolation based animation algorithm.}
    \label{tab:interpolation-animation-measurements}
\end{table}

\phantomsection{Depends on the chosen easing function}
\label{phantom:interpolation-deviation}
The deviation for this algorithm is defined as the integral of the absolute difference between the linear function and the chosen easing function:
\begin{align*}
    l(t) = t &: \text{linear function} \\
    \epsilon(t) &: \text{easing function} \\
    \bar{D} &= \int_{t=0}^{1} \left| l(t) - \epsilon(t) \right| dt
\end{align*}

\vspace{60pt}

\subsection{Timelines and sequencing}
\label{subsec:timelines-sequencing}

Many practical animations are compositions of multiple steps rather than a single, fixed-duration function. Timelines and sequencing provide a simple abstraction for assembling such compositions.

A \textbf{timeline} is an ordered collection of animations (or sequences) that are played one after another. Timelines may themselves be composed and can be executed in parallel with other timelines so that multiple objects are animated independently. A \textbf{sequence} is a single animation described by a set of keyframes or an interpolation procedure; it represents one contiguous part of a timeline.

\begin{Note}
    In this implementation, each timeline is represented as a generator function, following the same pattern as the \textbf{sequence} generator. To run multiple timelines concurrently, you create separate generator functions for each timeline and pass their generator instances to a parallel runner. For example, you can yield the parallel helper (represented here as {\footnotesize\texttt{Animator.runParallel(...)}}) from the main \textbf{sequence} generator to execute multiple timelines at the same time.
\end{Note}

\pagebreak

\begin{Note}
    When defining sequences within a timeline, the provided \textbf{InterpolationSequence} class uses a per-keyframe \textbf{duration} convention: each keyframe specifies the time interval from the previous keyframe to itself, rather than an absolute timestamp. This approach streamlines both implementation and editing, as you directly control the duration of each segment. However, it differs from traditional absolute-time timelines, where each keyframe has a specific time value. If needed, you can easily convert between these representations: cumulative sums of durations yield absolute times, while differences between absolute times yield per-segment durations. This system was chosen for its simplicity and efficiency, but it remains flexible enough to support absolute-time timelines if required.
\end{Note}

\Example{https://kisskonraduni.github.io/emergent-animations/examples/functional-animations?tab=2}{An example sequence can be found here}
\Example{https://kisskonraduni.github.io/emergent-animations/examples/functional-animations?tab=3}{and a more complex example can be found here}

\vspace{80pt}

\subsection{Data-driven animations}
\label{subsec:data-driven-animations}

There are animation techniques that rely on pre-recorded data rather than procedural generation. These methods can produce highly realistic results, as they are based on real-world motion capture or other data sources. However, they also have limitations, such as the need for large amounts of data and the difficulty of adapting the animation to different contexts.

A commonly used data-driven technique is motion capture, where the movements of a real person or animal are recorded and then applied to a digital character. This can produce highly realistic animations, but it requires specialized equipment and can be time-consuming and expensive. If the actor's size or proportions differ significantly from the digital character, the animation may look unnatural and may require a lot of manual adjustment.

Statistics are omitted for this algorithm, as it builds upon the interpolation-based animation technique discussed earlier. The only difference is that the keyframes are derived from external data rather than being manually defined.

\pagebreak

\subsection{Blend trees and directional blending}
\label{subsec:blend-trees-directional-blending}

Blend trees and directional blending are techniques used to combine multiple animations based on certain parameters, such as the direction of movement or the speed of an object. These methods allow for smooth transitions between different animations, creating a more natural and fluid motion.

These techniques are commonly used in video games and simulations, where we cannot predict the exact movements of the player or other objects. By blending between different animations based on the current state of the object, we can create a more dynamic and responsive animation system.

A common example of directional blending is a character that can walk in any direction. Instead of creating a separate animation for each possible direction, we can create a set of animations for the cardinal directions (up, down, left, right) and then blend between them based on the character's current movement direction.

An extra procedural animation can be applied to the character's upper body using a blend tree, allowing the player to aim in any direction while moving. This is a common technique in third-person shooter games, where the character's movement and aiming are controlled independently.

This technique was not implemented here, as it is quite complex and requires substantial data to work effectively. However, the concept is straightforward and builds upon the interpolation-based animation technique discussed earlier. Statistically, it would be almost identical to interpolation-based animation, with a slightly more natural feel due to the blending of multiple animations.

\vspace{30pt}

\subsection{Frame animations}
\label{subsec:frame-animations}

Frame animations are a common technique in computer graphics, particularly in 2D animation. They're based on the original concepts of filmmaking, where a series of still images are displayed in rapid succession to create the illusion of motion. In computer graphics, this is often implemented as a sequence of images or frames that are displayed one after another. Compression algorithms, sprite sheets, and similar techniques may cause the implementation to differ slightly, but the basic principle remains the same.

\begin{Note}
    In this implementation, I utilize spritesheets to store the frames of the animation, and a function to control which frame is shown at any given time. To use this, you need to define a regular \textbf{CanvasObject} and use the {\footnotesize\texttt{Objects.sprite(...)}} drawing function.
\end{Note}

\Example{https://kisskonraduni.github.io/emergent-animations/examples/frame-animations?tab=0}{An example frame animation can be found here}

\pagebreak

While frame animations are simple in concept, they can be combined with other techniques to create more complex results. For example, you can use frame animations to create a character that moves around the screen, while using interpolation to control the speed and direction of movement. This allows for a wide range of possibilities and can lead to interesting results.

I have created an example\footnote{
    This is not intended as a serious example; I created it while experimenting with the implementation. Surprisingly, it demonstrates how frame animations can be combined with other techniques, such as interpolation and parenting, to create more complex animations. It also shows how the implementation can be used to create animations with minimal effort.
} to show that these techniques are not mutually exclusive, and can be combined to create more complex animations. The example is a simple "pendulum" with three cats, each using its own frame animation.

\Example{https://kisskonraduni.github.io/emergent-animations/examples/frame-animations?tab=1}{Example can be found here}

\begin{table}[H]
    \centering
    \begin{tblr}{
        colspec={|c|c|c|c|c|},
        vlines = {abovepos = 1, belowpos = 1},
        hlines,
        hline{2} = {1}{-}{solid},
        hline{2} = {2}{-}{solid},
        row{1} = {font=\bfseries}
    }
        Deviation & Repetition & Control & Feel & Performance \\
        \(0.0\) & \(1.0\) & Total & \(N/A\) & \(O(1)\) \\
    \end{tblr}
    \caption{Measurements for the frame animation algorithm.}
    \label{tab:frame-animation-measurements}
\end{table}

The reason for omitting the feel measurement is that frame animations are not inherently tied to any specific timing or easing function. They simply display a sequence of images at a fixed rate, which can be adjusted independently of the animation itself. The feel of the animation is determined by the choice of frames and their timing, rather than the algorithm itself.

\vspace{30pt}

\subsection{Double buffering}
\label{subsec:double-buffering}

Double buffering is a technique used to reduce flickering and improve animation smoothness. It uses two buffers: while one is displayed, the other is drawn to in the background. When drawing is complete, the buffers are swapped, showing the new frame.

Although not strictly an animation technique, double buffering is often used alongside other methods to improve quality, especially for complex or slow rendering. This section serves as a segue, since many upcoming techniques rely on double buffering.

\begin{Note}
    Double buffering can be applied to data beyond images, such as simulation states or object positions in physics engines. Without it, execution order can cause inconsistencies. It also enables some multithreading, though this project does not use it due to language constraints.
\end{Note}

\pagebreak

\subsection{Rule-based animation systems}
\label{subsec:rule-based-animation-systems}

Rule-based animation systems use a set of predefined rules to determine how an object should move or change over time. These rules can be based on various factors, such as the object's current state, its environment, or user input. Rule-based systems are often used in games and simulations to create more dynamic and responsive animations.

A simple example is a basic implementation of Conway's Game of Life \cite{conway}. Each cell in a grid can be either alive or dead, and its state is determined by a set of rules based on the states of its neighboring cells.

\Example{https://kisskonraduni.github.io/emergent-animations/examples/rule-based-animations?tab=0}{My implementation can be found here}

This serves as a demonstration of how rule-based systems can be implemented and used to create interesting animations. It is not intended for direct comparison with the other algorithms, but rather to illustrate the fundamental concepts.

\subsection{Boids}
\label{subsec:boids}

Boids is a popular algorithm for simulating the flocking behavior of birds or fish. It was developed by Craig Reynolds in 1986 \cite{boids} and is based on three simple rules:
\begin{enumerate}
    \item \textbf{Separation}: steer to avoid crowding local flockmates
    \item \textbf{Alignment}: steer towards the average heading of local flockmates
    \item \textbf{Cohesion}: steer to move toward the average position of local flockmates
\end{enumerate}

Each boid (bird-like object) in the simulation follows these rules to determine its movement. The result is realistic flocking behavior that emerges from the simple interactions of individual boids.

\begin{Note}
    I have made some modifications to the original algorithm, including an extra rule to steer away from the edges of the screen, and the strength of most rules varies cubically with distance. The core concepts remain the same, and the result is similar to the original algorithm, but it is adapted to my preferences.
\end{Note}

\Example{https://kisskonraduni.github.io/emergent-animations/examples/rule-based-animations?tab=1}{My implementation can be found here}

\pagebreak

There are many parameters that can be adjusted to change the behavior of the flock. In my implementation, these controls are available in the bottom right corner of the interface. Some combinations of parameters may slow down the simulation significantly, as the algorithm is originally \(O(n^2)\) in complexity. Although I have implemented optimizations using a spatial grid \cite{spatial-grid}, it is still not efficient for very large numbers of boids.

\begin{table}[H]
    \centering
    \begin{tblr}{
        colspec={|c|c|c|c|c|},
        vlines = {abovepos = 1, belowpos = 1},
        hlines,
        hline{2} = {1}{-}{solid},
        hline{2} = {2}{-}{solid},
        row{1} = {font=\bfseries}
    }
        Deviation & Repetition & Control & Feel & Performance \\
        \(N/A\) & \(0.2\) & Medium & \(0.9\) & \(O(n^2)\) \\
    \end{tblr}
    \caption{Measurements for the boids algorithm.}
    \label{tab:boids-measurements}
\end{table}

The deviation metric is not defined for this algorithm, as it is not deterministic. The performance is also not strictly \(O(n^2)\) due to the spatial grid optimization; in theory, the best case achievable is \(O(n \log n)\).

\vspace{60pt}

\subsection{Inverse kinematics}
\label{subsec:inverse-forward-kinematics}

Inverse kinematics is a technique often used to animate limbs or other articulated structures. It involves calculating the positions and orientations of the individual segments of a structure based on the desired position of the end effector (e.g., a hand or foot). This is often used in character animation to ensure that a character's hand reaches a specific point in space, such as when grabbing an object.

Its most common use case, seen in many video games, is to ensure a character's feet remain in contact with the ground while walking on uneven terrain. This can be achieved by using inverse kinematics to adjust the position of the character's legs based on the height of the ground at each foot. When game developers create stairs, they often use a sloped collision surface and apply inverse kinematics to the character's legs so that the feet visually align with the steps, even if the steps themselves are only graphical.

This technique was not implemented in this project, but an example could have been included if time permitted. The concept is straightforward, and there are many resources available online that explain how to implement it. A simple implementation could use the Cyclic Coordinate Descent (CCD) algorithm \cite{ccd} or the Forward And Backward Reaching Inverse Kinematics (FABRIK) algorithm \cite{fabrik}.

As this technique was not implemented, exact statistics cannot be provided. However, based on its use in many games, it likely achieves a high feel rating and at least decent control.

\pagebreak

\subsection{Physics simulation based systems}
\label{subsec:physics-simulation-based-systems}

Physics simulation based systems use a physics engine to simulate the movement and interactions of objects in a virtual environment. This can be used to create realistic animations that respond to forces such as gravity, friction, and collisions. 

These simulations are used in a wide range of applications, from video games to scientific simulations. They can be used to create realistic animations of objects falling, bouncing, or colliding with each other. Physics simulations can also be used to create more complex animations, such as cloth simulation or fluid dynamics.

These systems are usually quite complex and computationally expensive, so in games we usually only use crude approximations to achieve a good balance between realism and performance. We use more advanced simulations for pre-rendered animations and visual effects in movies, where we can afford to spend more time on the simulation.

This is a topic that is too broad to cover in detail here, as there are many different types of physics simulations and many different algorithms used to implement them. This technique was not implemented in this project thanks to this.

